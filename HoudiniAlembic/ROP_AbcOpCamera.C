/*
 * Copyright (c) 2013
 *	Side Effects Software Inc.  All rights reserved.
 *
 * Redistribution and use of Houdini Development Kit samples in source and
 * binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. The name of Side Effects Software may not be used to endorse or
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY SIDE EFFECTS SOFTWARE `AS IS' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 * NO EVENT SHALL SIDE EFFECTS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *----------------------------------------------------------------------------
 */

#include "ROP_AbcOpCamera.h"
#include <OBJ/OBJ_Camera.h>
#include <CH/CH_Channel.h>
#include <OP/OP_Director.h>
#include <GABC/GABC_OError.h>
#include "ROP_AbcContext.h"

using namespace GABC_NAMESPACE;

namespace
{
    typedef Alembic::AbcGeom::OCamera		OCamera;
    typedef Alembic::AbcGeom::CameraSample	CameraSample;

    static bool
    fillSample(CameraSample &sample, OBJ_Camera *cam, const ROP_AbcContext &ctx)
    {
	const CH_Manager	*chman = OPgetDirector()->getChannelManager();
	fpreal	now = ctx.cookTime();
	fpreal	winx = cam->WINX(now);
	fpreal	winy = cam->WINY(now);
	fpreal	winsizex = cam->WINSIZEX(now);
	fpreal	winsizey = cam->WINSIZEY(now);
	fpreal	focal = cam->FOCAL(now);
	fpreal	aperture = cam->APERTURE(now);
	fpreal	aspect = cam->ASPECT(now);
	fpreal	resx = cam->RESX(now);
	fpreal	resy = cam->RESY(now);
	fpreal	fstop = cam->FSTOP(now);
	fpreal	focus = cam->FOCUS(now);
	fpreal	hither = cam->getNEAR(now);
	fpreal	yon = cam->getFAR(now);
	fpreal	shutter = cam->SHUTTER(now);

	// Compute resolution aspect
	fpreal	raspect = resy/resx;

	// Alembic stores value in cm. (not mm.)
	aperture *= 0.1;

	sample.setFocalLength(focal);

	sample.setHorizontalAperture(aperture);
	sample.setVerticalAperture(aperture * raspect);
	sample.setHorizontalFilmOffset(winx * aperture / aspect);
	sample.setVerticalFilmOffset(winy * aperture * raspect / aspect);
	sample.setLensSqueezeRatio(aspect);

	sample.setOverScanLeft(0);
	sample.setOverScanRight(0);
	sample.setOverScanTop(0);
	sample.setOverScanBottom(0);

	sample.setFStop(fstop);
	sample.setFocusDistance(focus);

	sample.setShutterOpen(0);
	sample.setShutterClose(chman->getTimeDelta(shutter));

	sample.setNearClippingPlane(hither);
	sample.setFarClippingPlane(yon);

	// We need to output the filmback fit and post projection transform
	Alembic::AbcGeom::FilmBackXformOp	winsize(
		Alembic::AbcGeom::kScaleFilmBackOperation, "winsize");
	sample.addOp(winsize);
	sample[0].setChannelValue(0, winsizex);
	sample[0].setChannelValue(1, winsizey);
	return true;
    }

    static const char	*theChannelNames[] = {
	"winx",
	"winy",
	"winsizex",
	"winsizey",
	"focal",
	"aperture",
	"aspect",
	"resx",
	"resy",
	"fstop",
	"focus",
	"near",
	"far",
	"shutter",
    };
    #define NUM_CHANNELS	(sizeof(theChannelNames)/sizeof(const char *))

    static bool
    checkTimeDependent(OBJ_Camera *cam)
    {
	// check if there are any animated parameters
	for (int i = 0; i < NUM_CHANNELS; ++i)
	{
	    const CH_Channel	*chp = cam->getChannel(theChannelNames[i]);
	    if (chp && chp->isTimeDependent())
		return true;
	}
	return false;
    }

    OBJ_Camera *
    getCamera(int id)
    {
	OP_Node	*node = OP_Node::lookupNode(id);
	return UTverify_cast<OBJ_Camera *>(node);
    }

    void
    nodeFullPath(UT_WorkBuffer &buf, int id)
    {
	OBJ_Camera	*o = getCamera(id);
	if (!o)
	    buf.sprintf("Camera with unique id %d was deleted", id);
	else
	    o->getFullPath(buf);
    }
}

ROP_AbcOpCamera::ROP_AbcOpCamera(OBJ_Camera *node)
    : myCameraId(node ? node->getUniqueId() : -1)
    , myOCamera()
    , myTimeDependent(false)
{
}

ROP_AbcOpCamera::~ROP_AbcOpCamera()
{
}

bool
ROP_AbcOpCamera::start(const OObject &parent,
	GABC_OError &err, const ROP_AbcContext &ctx, UT_BoundingBox &box)
{
    OBJ_Camera	*cam = getCamera(myCameraId);
    myOCamera = OCamera(parent, getName(), ctx.timeSampling());
    if (!cam || !myOCamera)
    {
	UT_WorkBuffer	fullpath;
	nodeFullPath(fullpath, myCameraId);
	return err.error("Unable to create camera for %s", fullpath.buffer());
    }

    UT_ASSERT(!childCount());

    myTimeDependent = checkTimeDependent(cam);

    // Now, just do an update
    return update(err, ctx, box);
}

bool
ROP_AbcOpCamera::update(GABC_OError &err,
	const ROP_AbcContext &ctx, UT_BoundingBox &box)
{
    OBJ_Camera	*cam = getCamera(myCameraId);
    if (!cam)
	return false;
    CameraSample	sample;
    fillSample(sample, cam, ctx);
    myOCamera.getSchema().set(sample);
    box.initBounds(0, 0, 0);

    return true;
}

bool
ROP_AbcOpCamera::selfTimeDependent() const
{
    return myTimeDependent;
}

bool
ROP_AbcOpCamera::getLastBounds(UT_BoundingBox &box) const
{
    box.initBounds(0, 0, 0);
    return true;
}
