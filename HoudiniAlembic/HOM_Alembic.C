/*
 * Copyright (c) 2014
 *	Side Effects Software Inc.  All rights reserved.
 *
 * Redistribution and use of Houdini Development Kit samples in source and
 * binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. The name of Side Effects Software may not be used to endorse or
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY SIDE EFFECTS SOFTWARE `AS IS' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 * NO EVENT SHALL SIDE EFFECTS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *----------------------------------------------------------------------------
 */

//-*****************************************************************************
//
// Copyright (c) 2009-2012,
//  Sony Pictures Imageworks Inc. and
//  Industrial Light & Magic, a division of Lucasfilm Entertainment Company Ltd.
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// *       Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// *       Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// *       Neither the name of Sony Pictures Imageworks, nor
// Industrial Light & Magic, nor the names of their contributors may be used
// to endorse or promote products derived from this software without specific
// prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//-*****************************************************************************

// The python developers recomment that Python.h be includede before any other
// header files.
#include <PY/PY_CPythonAPI.h>
// This file contains functions that will run arbitrary Python code
#include <PY/PY_Python.h>
#include <PY/PY_InterpreterAutoLock.h>
#include <GABC/GABC_IArchive.h>
#include <GABC/GABC_Util.h>
#include <Alembic/AbcGeom/All.h>
#include <HOM/HOM_Module.h>
#include <UT/UT_DSOVersion.h>
#include <UT/UT_StackBuffer.h>
#include <GT/GT_DataArray.h>

using namespace GABC_NAMESPACE;
namespace
{
    typedef GABC_IObject			IObject;
    typedef Alembic::Abc::index_t		index_t;
    typedef Alembic::Abc::chrono_t		chrono_t;
    typedef Alembic::Abc::V2d			V2d;
    typedef Alembic::Abc::ObjectHeader		ObjectHeader;
    typedef Alembic::Abc::ISampleSelector	ISampleSelector;
    typedef Alembic::Abc::TimeSamplingPtr	TimeSamplingPtr;
    typedef Alembic::AbcGeom::IXform		IXform;
    typedef Alembic::AbcGeom::ICamera		ICamera;
    typedef Alembic::AbcGeom::ICameraSchema	ICameraSchema;
    typedef Alembic::AbcGeom::CameraSample	CameraSample;
    typedef Alembic::AbcGeom::FilmBackXformOp	FilmBackXformOp;

    static PY_PyObject *
    alembicGetXform(PY_PyObject *self, PY_PyObject *args, int result_size,
	    bool localx)
    {
	const char	*filename = NULL;
	const char	*objectPath = NULL;
	double		 sampleTime = 0.0;
	bool		 isConstant = true;
	bool		 inheritsXform = true;
	UT_Matrix4D	 xform;

        if (!PY_PyArg_ParseTuple(args, "ssd", &filename, &objectPath,
                &sampleTime))
	{
	    return NULL;
	}
	bool	ok;
	if (localx)
	    ok = GABC_Util::getLocalTransform(filename, objectPath,
		    sampleTime, xform, isConstant, inheritsXform);
	else
	    ok = GABC_Util::getWorldTransform(filename, objectPath,
		    sampleTime, xform, isConstant, inheritsXform);
	if (!ok)
	    xform.identity();

	const double	*data = xform.data();
        PY_PyObject* matrixTuple = PY_PyTuple_New(16);
        for (PY_Py_ssize_t i = 0; i < 16; ++i)
        {
            PY_PyTuple_SET_ITEM(matrixTuple, i, PY_PyFloat_FromDouble(data[i]));
        }
        PY_PyObject *result = PY_PyTuple_New(result_size);
        PY_PyTuple_SET_ITEM(result, 0, matrixTuple);
        PY_PyTuple_SET_ITEM(result, 1, PY_PyInt_FromLong(isConstant));
	if (result_size > 2)
	    PY_PyTuple_SET_ITEM(result, 2, PY_PyInt_FromLong(inheritsXform));
        return result;
    }

    static const char	*Doc_AlembicGetLocalXform =
	"(xform, isConstant) = alembicGetLocalXform(abcPath, objectPath, sampleTime)\n"
	"\n"
	"Returns a tuple (xform,isConstant) containing the transform and a\n"
	"flag indicating whether the transform is animated or constant. The\n"
	"transform is a 16-tuple of floats.\n"
	"\n"
	"This is deprecated in favour of getLocalXform()";	// 12.5

    PY_PyObject *
    Py_AlembicGetLocalXform(PY_PyObject *self, PY_PyObject *args)
    {
	return alembicGetXform(self, args, 2, true);
    }

    static const char	*Doc_GetLocalXform =
	"(xform, isConstant, inherit) = getLocalXform(abcPath, objectPath, sampleTime)\n"
	"\n"
	"Returns a tuple (xform,isConstant,inherits) containing the transform\n"
	"and flags indicating whether the transform is animated/constant,\n"
	"along with whether the node inherit it's parent transform (or is\n"
	"disconnected from the transform hierarchy).";

    PY_PyObject *
    Py_GetLocalXform(PY_PyObject *self, PY_PyObject *args)
    {
	return alembicGetXform(self, args, 3, true);
    }

    static const char	*Doc_GetWorldXform =
	"(xform, isConstant, inherit) = getWorldXform(abcPath, objectPath, sampleTime)\n"
	"\n"
	"Returns a tuple (xform,isConstant,inherits) containing the object to\n"
	"world transform flags indicating whether the transform is animated\n"
	"or constant, along with whether the node inherit it's parent\n"
	"transform (or is disconnected from the transform hierarchy).";

    PY_PyObject *
    Py_GetWorldXform(PY_PyObject *self, PY_PyObject *args)
    {
	return alembicGetXform(self, args, 3, false);
    }

    static PY_PyObject *
    extractTuple(const GT_DataArrayHandle &array, exint idx)
    {
	GT_Size		 tsize = array->getTupleSize();
	PY_PyObject	*tuple = PY_PyTuple_New(tsize);
	if (GTisFloat(array->getStorage()))
	{
	    UT_StackBuffer<fpreal>	buf(tsize);
	    array->import(idx, buf, tsize);
	    for (GT_Size i = 0; i < tsize; ++i)
		PY_PyTuple_SetItem(tuple, i, PY_PyFloat_FromDouble(buf[i]));
	}
	else if (GTisInteger(array->getStorage()))
	{
	    UT_StackBuffer<int64>	buf(tsize);
	    array->import(idx, buf, tsize);
	    for (GT_Size i = 0; i < tsize; ++i)
		PY_PyTuple_SetItem(tuple, i, PY_PyInt_FromLong(buf[i]));
	}
	else
	{
	    for (GT_Size i = 0; i < tsize; ++i)
	    {
		PY_PyTuple_SetItem(tuple, i,
			PY_PyString_FromString(array->getS(idx, i)));
	    }
	}
	return tuple;
    }

    static PY_PyObject *
    dataFromArray(const GT_DataArrayHandle &array)
    {
	GT_Size		 size = array ? array->entries() : 0;
	GT_Size		 tsize = array ? array->getTupleSize() : 0;
	PY_PyObject	*list = PY_PyList_New(size);
	if (size)
	{
	    if (tsize > 1)
	    {
		for (exint i = 0; i < size; ++i)
		    PY_PyList_SetItem(list, i, extractTuple(array, i));
	    }
	    else if (GTisInteger(array->getStorage()))
	    {
		for (exint i = 0; i < size; ++i)
		    PY_PyList_SetItem(list, i, PY_PyInt_FromLong(array->getI64(i)));
	    }
	    else if (GTisFloat(array->getStorage()))
	    {
		for (exint i = 0; i < size; ++i)
		    PY_PyList_SetItem(list, i, PY_PyFloat_FromDouble(array->getF64(i)));
	    }
	    else
	    {
		for (exint i = 0; i < size; ++i)
		    PY_PyList_SetItem(list, i, PY_PyString_FromString(array->getS(i)));
	    }
	}
	return list;
    }

    static const char *
    scopeName(Alembic::AbcGeom::GeometryScope scope)
    {
	switch (scope)
	{
	    case Alembic::AbcGeom::kConstantScope:
		return "constant";
	    case Alembic::AbcGeom::kUniformScope:
		return "uniform";
	    case Alembic::AbcGeom::kVaryingScope:
		return "varying";
	    case Alembic::AbcGeom::kVertexScope:
		return "vertex";
	    case Alembic::AbcGeom::kFacevaryingScope:
		return "facevarying";
	    default:
		break;
	}
	return "unknown";
    }

    static const char	*Doc_ArbGeometry =
	"(value, isConstant, scope) = alembicArbGeometry(abcPath, objectPath, name, sampleTime)\n"
	"\n"
	"Returns None or a tuple (value,isConstant,scope).  The tuple\n"
	"contains the value for the attribute, it's scope ('varying',\n"
	"'vertex', 'facevarying', 'uniform', 'constant' or 'unknown') and\n"
	"a boolean flag indicating whether the attribute is constant over\n"
	"time or not.";

    PY_PyObject *
    Py_AlembicArbGeometry(PY_PyObject *self, PY_PyObject *args)
    {
	const char			*filename;
	const char			*objectPath;
	const char			*name;
	double				 sampleTime;
	Alembic::AbcGeom::GeometryScope	 scope;
	GEO_AnimationType		 atype;
	GT_DataArrayHandle		 data;

        if (!PY_PyArg_ParseTuple(args, "sssd", &filename, &objectPath,
                &name, &sampleTime))
	{
	    return NULL;
	}

	GABC_IObject	obj = GABC_Util::findObject(filename, objectPath);
	if (!obj.valid())
	{
	    PY_Py_RETURN_NONE;
	}
	data = obj.getGeometryProperty(name, sampleTime, scope, atype);
	PY_PyObject	*rcode = PY_PyTuple_New(3);
	PY_PyTuple_SetItem(rcode, 0, dataFromArray(data));
	PY_PyTuple_SetItem(rcode, 1, atype == GEO_ANIMATION_CONSTANT ? PY_Py_True() : PY_Py_False());
	PY_PyTuple_SetItem(rcode, 2, PY_PyString_FromString(scopeName(scope)));
	PY_Py_INCREF(rcode);
	return rcode;
    }

    static const char	*Doc_UserProperty =
	"(value, isConstant) = alembicUserProperty(abcPath, objectPath, name, sampleTime)\n"
	"\n"
	"Returns None or a tuple (value,isConstant).  The tuple contains the\n"
	"value for the attribute, and a boolean flag indicating whether the\n"
	"attribute is constant over time or not.\n";

    PY_PyObject *
    Py_AlembicUserProperty(PY_PyObject *self, PY_PyObject *args)
    {
	const char			*filename;
	const char			*objectPath;
	const char			*name;
	double				 sampleTime;
	GEO_AnimationType		 atype;
	GT_DataArrayHandle		 data;

        if (!PY_PyArg_ParseTuple(args, "sssd", &filename, &objectPath,
                &name, &sampleTime))
	{
	    return NULL;
	}

	GABC_IObject	obj = GABC_Util::findObject(filename, objectPath);
	if (!obj.valid())
	{
	    PY_Py_RETURN_NONE;
	}
	data = obj.getUserProperty(name, sampleTime, atype);
	PY_PyObject	*rcode = PY_PyTuple_New(2);
	PY_PyTuple_SetItem(rcode, 0, dataFromArray(data));
	PY_PyTuple_SetItem(rcode, 1, atype == GEO_ANIMATION_CONSTANT ? PY_Py_True() : PY_Py_False());
	PY_Py_INCREF(rcode);
	return rcode;
    }

    static const char	*Doc_Visibility =
	"(value, isConstant) = alembicVisibility(abcPath, objectPath, sampleTime, [check_ancestor=False])\n"
	"\n"
	"Returns None or a tuple (value,isConstant).  The tuple contains the\n"
	"visibility for the object, and a boolean flag indicating whether\n"
	"visibility is constant over the animation.  The visibility returned\n"
	"is an integer where 0 := hidden, 1 := visible, and -1 is deferred\n"
	"(dependent on parent visibility).\n";

    PY_PyObject *
    Py_AlembicVisibility(PY_PyObject *self, PY_PyObject *args)
    {
	const char			*filename;
	const char			*objectPath;
	double				 sampleTime;
	int				 check_parent;
	GT_DataArrayHandle		 data;

	// Usage: alembicVisiblity(file, object, time, [checkparent=False])
	check_parent = 0;
        if (!PY_PyArg_ParseTuple(args, "ssd|i", &filename, &objectPath,
                &sampleTime, &check_parent))
	{
	    return NULL;
	}

	GABC_IObject	obj = GABC_Util::findObject(filename, objectPath);
	if (!obj.valid())
	{
	    PY_Py_RETURN_NONE;
	}
	bool	animated = false;
	int	result = obj.visibility(animated, sampleTime,
					check_parent != 0);

	PY_PyObject	*rcode = PY_PyTuple_New(2);
	PY_PyTuple_SetItem(rcode, 0, PY_PyInt_FromLong(result));
	PY_PyTuple_SetItem(rcode, 1, animated ? PY_Py_False() : PY_Py_True());
	PY_Py_INCREF(rcode);
	return rcode;
    }


    class PyWalker : public GABC_Util::Walker
    {
    public:
	PyWalker()
	    : myRoot(NULL)
	{
	}
	~PyWalker()
	{
	}
	virtual bool	process(const IObject &root)
			{
			    myRoot = walkNode(root);
			    return false;
			}

	PY_PyObject	*walkNode(const IObject &obj)
	{
	    const char		*otype = "<unknown>";
	    switch (obj.nodeType())
	    {
		case GABC_XFORM:
		    {
			IXform	xform(obj.object(), Alembic::Abc::kWrapExisting);
			if (xform.getSchema().isConstant())
			    otype = "cxform";
			else
			    otype = "xform";
		    }
		    break;
		case GABC_POLYMESH:
		    otype = "polymesh";
		    break;
		case GABC_SUBD:
		    otype = "subdmesh";
		    break;
		case GABC_CAMERA:
		    otype = "camera";
		    break;
		case GABC_FACESET:
		    otype = "faceset";
		    break;
		case GABC_CURVES:
		    otype = "curves";
		    break;
		case GABC_POINTS:
		    otype = "points";
		    break;
		case GABC_NUPATCH:
		    otype = "nupatch";
		    break;
		default:
		    otype = "unknown";
		    break;
	    }

	    exint nkids = const_cast<IObject *>(&obj)->getNumChildren();
	    PY_PyObject *result = PY_PyTuple_New(3);
	    PY_PyObject *kids = PY_PyTuple_New(nkids);;

	    PY_PyTuple_SET_ITEM(result, 0,
		    PY_PyString_FromString(obj.getName().c_str()));
	    PY_PyTuple_SET_ITEM(result, 1, PY_PyString_FromString(otype));
	    PY_PyTuple_SET_ITEM(result, 2, kids);

	    for (exint i = 0; i < nkids; ++i)
	    {
		PY_PyTuple_SET_ITEM(kids, i,
			walkNode(const_cast<IObject *>(&obj)->getChild(i)));
	    }
	    return result;
	}
	PY_PyObject	*getObject() const	{ return myRoot; }

    private:
	PY_PyObject	*myRoot;
    };

    //-*************************************************************************
    static const char	*Doc_AlembicGetSceneHierarchy =
	"alembicGetSceneHierarchy(abcPath, objectPath)\n"
	"\n"
	"Returns a tree of tuples.  Each tuple is constructed as:\n"
	"	node[0] := object_name\n"
	"	node[1] := object_type\n"
	"	node[2] := (children)\n"
	"Where (children) is a tuple containing the child nodes.\n"
	"Object types include (but may contain other types):\n"
	"  - cxform    A constant transform node\n"
	"  - xform     An animated transform node\n"
	"  - camera    A camera node\n"
	"  - polymesh  A Polygon Mesh shape node\n"
	"  - subdmesh  A Subdivision Surface Mesh shape node\n"
	"  - faceset   A Face Set shape node\n"
	"  - curves    A Curves shape node\n"
	"  - points    A Points shape node\n"
	"  - nupatch   A NuPatch shape node\n"
	"  - unknown   An unknown node";

    PY_PyObject *
    Py_AlembicGetSceneHierarchy(PY_PyObject *self, PY_PyObject *args)
    {
        const char * archivePath = NULL;
        const char * objectPath = NULL;
        if (!PY_PyArg_ParseTuple(args, "ss", &archivePath, &objectPath))
	    return NULL;

	PyWalker	walker;
	UT_StringArray	objects;
	objects.append(objectPath);
	GABC_Util::walk(archivePath, walker, objects);
	return walker.getObject();
    }

    //-*************************************************************************
    static const char	*Doc_AlembicClearArchiveCache =
	"alembicClearArchiveCache()\n"
	"\n"
	"Clear the internal cache of Alembic files";

    PY_PyObject *
    Py_AlembicClearArchiveCache(PY_PyObject *self, PY_PyObject *args)
    {
	GABC_Util::clearCache();
        PY_Py_RETURN_NONE;
    }

    static const char	*Doc_AlembicSetArchiveMaxCacheSize =
	"alembicSetArchiveMaxCacheSize(size)\n"
	"\n"
	"Set the maximum number of Alembic files cached at one time.";

    PY_PyObject *
    Py_AlembicSetArchiveMaxCacheSize(PY_PyObject *self, PY_PyObject *args)
    {
        unsigned int value;

        if (!PY_PyArg_ParseTuple(args, "I", &value))
	    return NULL;

	GABC_Util::setFileCacheSize(value);

        PY_Py_RETURN_NONE;
    }

    static const char	*Doc_AlembicGetArchiveMaxCacheSize =
	"alembicGetArchiveMaxCacheSize()\n"
	"\n"
	"Return the Alembic files cache size.";

    PY_PyObject *
    Py_AlembicGetArchiveMaxCacheSize(PY_PyObject *self, PY_PyObject *args)
    {
        return PY_PyInt_FromLong(GABC_Util::fileCacheSize());
    }

    //-*************************************************************************

    static const char	*Doc_AlembicGetObjectPathListForMenu =
	"alembicGetObjectPathListForMenu(abcPath)\n"
	"\n"
	"Returns a tuple of strings in the form expected for menu callbacks.\n"
	"That is, each object is duplicated as a token/label pair.";

    PY_PyObject *
    Py_AlembicGetObjectPathListForMenu(PY_PyObject *self, PY_PyObject *args)
    {
        const char *filename = NULL;
        if (!PY_PyArg_ParseTuple(args, "s", &filename))
	    return NULL;

	// TODO: Would be nice to have a tree instead of a flat list
	const GABC_Util::PathList &objects = GABC_Util::getObjectList(filename);
	exint		 nobj = objects.size();
	PY_PyObject	*result = PY_PyList_New(nobj*2);
	for (exint i = 0; i < nobj; ++i)
	{
	    PY_PyObject	*name = PY_PyString_FromString(objects[i].c_str());
	    PY_Py_INCREF(name);	// For second reference in list
	    PY_PyList_SetItem(result, i*2, name);	// Token
	    PY_PyList_SetItem(result, i*2+1, name);	// Label
	}

        return result;
    }

    //-*************************************************************************

    static const char	*Doc_AlembicGetCameraDict =
	"alembicGetCameraDict(abcPath, objectPath, sampleTime)\n"
	"\n"
	"Returns a dictionary of camera parameters for the given object.";

    class HoudiniCam
    {
    public:
	HoudiniCam(CameraSample &sample)
	{
	    fpreal squeeze = sample.getLensSqueezeRatio();

	    myFocal = sample.getFocalLength();
	    myFocus = sample.getFocusDistance();
	    myAperture = sample.getHorizontalAperture()*10.0;
	    myClipping[0] = sample.getNearClippingPlane();
	    myClipping[1] = sample.getFarClippingPlane();

	    double	top, bottom, left, right;
	    sample.getScreenWindow(top, bottom, left, right);

	    fpreal winx = sample.getHorizontalFilmOffset() *
		    sample.getLensSqueezeRatio()/sample.getHorizontalAperture();
	    fpreal winy = sample.getVerticalFilmOffset() /
	            sample.getVerticalAperture();

	    //TODO, full 2D transformations
	    V2d postScale(1.0, 1.0);
	    for ( size_t i = 0; i < sample.getNumOps(); ++i )
	    {
		const FilmBackXformOp	&op = sample.getOp(i);
		if (op.isScaleOp())
		{
		    if (!op.getHint().compare("preScale")
		        || !op.getHint().compare("postScale")
		        || !op.getHint().compare("cameraScale"))
		    {
		        postScale *= op.getScale();
		    }
		}
	    }

	    //TODO overscan
	    fpreal winsizex = squeeze / postScale[0];
	    myWinSize[0] = winsizex;
	    myWinSize[1] = postScale[1];

	    myWinOffset[0] = winx;
	    myWinOffset[1] = winy;
	}
	void	blend(const HoudiniCam &src, fpreal w)
	{
	    myFocal = SYSlerp(myFocal, src.myFocal, w);
	    myFocus = SYSlerp(myFocus, src.myFocus, w);
	    myAperture = SYSlerp(myAperture, src.myAperture, w);
	    myClipping[0] = SYSlerp(myClipping[0], src.myClipping[0], w);
	    myClipping[1] = SYSlerp(myClipping[1], src.myClipping[1], w);
	    myWinOffset[0] = SYSlerp(myWinOffset[0], src.myWinOffset[0], w);
	    myWinOffset[1] = SYSlerp(myWinOffset[1], src.myWinOffset[1], w);
	    myWinSize[0] = SYSlerp(myWinSize[0], src.myWinSize[0], w);
	    myWinSize[1] = SYSlerp(myWinSize[1], src.myWinSize[1], w);
	}

	static void	setItem(PY_PyObject *dict, const char *key, fpreal val)
	{
	    PY_PyObject	*v = PY_PyFloat_FromDouble(val);
	    PY_PyDict_SetItemString(dict, key, v);
	    PY_Py_DECREF(v);
	}
	void	setDict(PY_PyObject *dict) const
	{
	    setItem(dict, "focal", myFocal);
	    setItem(dict, "focus", myFocus);
	    setItem(dict, "aperture", myAperture);
	    setItem(dict, "near", myClipping[0]);
	    setItem(dict, "far", myClipping[1]);
	    setItem(dict, "winx", myWinOffset[0]);
	    setItem(dict, "winy", myWinOffset[1]);
	    setItem(dict, "winsizex", myWinSize[0]);
	    setItem(dict, "winsizey", myWinSize[1]);
	}

	fpreal	myFocal;
	fpreal	myFocus;
	fpreal	myAperture;
	fpreal	myClipping[2];
	fpreal	myWinOffset[2];
	fpreal	myWinSize[2];
    };

    static const fpreal	theTimeBias = 0.0001;
    static fpreal
    blendTime(fpreal t,
	    const TimeSamplingPtr &itime,
	    exint nsamp,
	    index_t &i0,
	    index_t &i1)
    {
	nsamp = SYSmax(nsamp, 1);
	std::pair<index_t, chrono_t>	t0 = itime->getFloorIndex(t, nsamp);
	i0 = i1 = t0.first;
	if (nsamp == 1 || SYSisEqual(t, t0.second, theTimeBias))
	    return 0;
	std::pair<index_t, chrono_t>	t1 = itime->getCeilIndex(t, nsamp);
	i1 = t1.first;
	if (i0 == i1)
	    return 0;
	fpreal	bias = (t - t0.second) / (t1.second - t0.second);
	if (SYSisEqual(bias, 1, theTimeBias))
	{
	    i0 = i1;
	    return 0;
	}
	return bias;
    }

    PY_PyObject *
    Py_AlembicGetCameraDict(PY_PyObject *self, PY_PyObject *args)
    {
	const char	*archivePath = NULL;
	const char	*objectPath = NULL;
	double		 sampleTime = 0.0;
	PY_PyObject	*resultDict = PY_PyDict_New();

        if (!PY_PyArg_ParseTuple(args, "ssd", &archivePath, &objectPath,
                &sampleTime)) return NULL;

	try
	{
	    IObject	obj = GABC_Util::findObject(archivePath, objectPath);

	    if (obj.valid() && ICamera::matches(obj.getHeader()))
	    {
		ICamera camera(obj.object(), Alembic::Abc::kWrapExisting);
		ICameraSchema	schema = camera.getSchema();
		index_t	i0, i1;
		fpreal	bias = blendTime(sampleTime,
				    schema.getTimeSampling(),
				    schema.getNumSamples(), i0, i1);
		CameraSample	sample0 = schema.getValue(ISampleSelector(i0));
		HoudiniCam	hcam0(sample0);
		if (i0 != i1)
		{
		    CameraSample s1 = schema.getValue(ISampleSelector(i1));
		    hcam0.blend(HoudiniCam(s1), bias);
		}
		hcam0.setDict(resultDict);
	    }
	}
	catch (const std::exception &e)
	{
	    PY_PyObject *val = PY_PyString_FromString(e.what());
	    PY_PyDict_SetItemString(resultDict, "error", val);
	    PY_Py_DECREF(val);
	}

        return resultDict;
    }
}

void
HOMextendLibrary()
{
    {
    // A PY_InterpreterAutoLock will grab the Python global interpreter
    // lock (GIL).  It's important that we have the GIL before making
    // any calls into the Python API.
    PY_InterpreterAutoLock interpreter_auto_lock;

    static PY_PyMethodDef alembic_hom_extension_methods[] =
    {
        {"getLocalXform", Py_GetLocalXform,
                PY_METH_VARARGS(), Doc_GetLocalXform},
        {"getWorldXform", Py_GetWorldXform,
                PY_METH_VARARGS(), Doc_GetWorldXform},
        {"alembicGetLocalXform", Py_AlembicGetLocalXform,
                PY_METH_VARARGS(), Doc_AlembicGetLocalXform},
        {"alembicGetSceneHierarchy", Py_AlembicGetSceneHierarchy,
                PY_METH_VARARGS(), Doc_AlembicGetSceneHierarchy},

        {"alembicClearArchiveCache", Py_AlembicClearArchiveCache,
                PY_METH_VARARGS(), Doc_AlembicClearArchiveCache},
        {"alembicSetArchiveMaxCacheSize", Py_AlembicSetArchiveMaxCacheSize,
                PY_METH_VARARGS(), Doc_AlembicSetArchiveMaxCacheSize},
        {"alembicGetArchiveMaxCacheSize", Py_AlembicGetArchiveMaxCacheSize,
                PY_METH_VARARGS(), Doc_AlembicGetArchiveMaxCacheSize}, 
        {"alembicGetObjectPathListForMenu", Py_AlembicGetObjectPathListForMenu,
                PY_METH_VARARGS(), Doc_AlembicGetObjectPathListForMenu },
        {"alembicGetCameraDict", Py_AlembicGetCameraDict,
                PY_METH_VARARGS(), Doc_AlembicGetCameraDict },

	{ "alembicArbGeometry", Py_AlembicArbGeometry,
		PY_METH_VARARGS(), Doc_ArbGeometry },
	{ "alembicUserProperty", Py_AlembicUserProperty,
		PY_METH_VARARGS(), Doc_UserProperty },

	{ "alembicVisibility",	Py_AlembicVisibility,
		PY_METH_VARARGS(), Doc_Visibility },

        { NULL, NULL, 0, NULL }
    };
    PY_Py_InitModule("_alembic_hom_extensions", alembic_hom_extension_methods);
    }


    PYrunPythonStatementsAndExpectNoErrors(
    "def _alembicGetCameraDict(self, archivePath, objectPath, sampleTime):\n"
    "    '''Return camera information.'''\n"
    "    import _alembic_hom_extensions\n"
    "    return _alembic_hom_extensions.alembicGetCameraDict(archivePath, objectPath, sampleTime)\n"
    "__import__('hou').ObjNode.alembicGetCameraDict = _alembicGetCameraDict\n"
    "del _alembicGetCameraDict\n");
}
