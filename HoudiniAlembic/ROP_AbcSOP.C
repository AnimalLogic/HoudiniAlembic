/*
 * Copyright (c) 2014
 *	Side Effects Software Inc.  All rights reserved.
 *
 * Redistribution and use of Houdini Development Kit samples in source and
 * binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. The name of Side Effects Software may not be used to endorse or
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY SIDE EFFECTS SOFTWARE `AS IS' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 * NO EVENT SHALL SIDE EFFECTS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *----------------------------------------------------------------------------
 */

#include "ROP_AbcSOP.h"
#include "ROP_AbcGTCompoundShape.h"
#include "ROP_AbcGTShape.h"
#include <GABC/GABC_OError.h>
#include <GABC/GABC_OXform.h>
#include <GABC/GABC_PackedImpl.h>
#include <GT/GT_Refine.h>
#include <GT/GT_GEODetail.h>
#include <GT/GT_Primitive.h>
#include <GT/GT_RefineParms.h>
#include <SOP/SOP_Node.h>

using namespace GABC_NAMESPACE;

namespace
{
    typedef Alembic::AbcGeom::ObjectVisibility	ObjectVisibility;

    typedef ROP_AbcSOP::abc_PrimContainer       abc_PrimContainer;
    typedef ROP_AbcSOP::NameList                NameList;
    typedef ROP_AbcSOP::PartitionMap            PartitionMap;
    typedef ROP_AbcSOP::PartitionMapInsert      PartitionMapInsert;
    typedef ROP_AbcSOP::PrimitiveList           PrimitiveList;

    static void
    buildGeometry(PrimitiveList &primitives,
	    const GU_Detail &gdp,
	    const GA_Range &range,
            const std::string &identifier,
            bool has_partition,
            bool check_alembic,
	    bool force_subd_mode,
	    bool show_pts)
    {
	/// Since there can be all kinds of primitives we don't understand
	/// (i.e. all custom ones, Tetra, etc. we build a GT primitive for the
	/// detail.  We can refine this into simpler primitives until we *do*
	/// understand them.
	GT_PrimitiveHandle	detail = GT_GEODetail::makeDetail(&gdp, &range);
	if (detail)
	{
            bool    has_alembic = false;

	    if (check_alembic)
	    {
                // Check the range for packed Alembic primitives.
                // This is used for sorting primitives; partitions with
                // packed Alembics must come first.
                for (GA_Iterator it(range); !it.atEnd(); ++it)
                {
                    if (gdp.getPrimitive(*it)->getTypeId()
                            == GABC_PackedImpl::typeId())
                    {
                        has_alembic = true;
                        break;
                    }
                }
            }

	    primitives.append(abc_PrimContainer(detail,
	            &identifier,
	            has_alembic,
	            has_partition,
	            force_subd_mode,
	            show_pts));
	}
    }

    static bool
    isToggleEnabled(OP_Node *node, const char *name,
	    const ROP_AbcContext &ctx, bool def)
    {
	int	value;
	if (node->evalParameterOrProperty(name, 0, ctx.cookTime(), value))
	    return value != 0;
	return def;
    }

    static bool
    objectSubd(const SOP_Node *sop, const ROP_AbcContext &ctx,
	    UT_String &groupname)
    {
	// If the user has specified a subd group on the output driver, any
	// polygons in the subd group will be output as OSubD.  All others will
	// be output as OPolyMesh.
	groupname = ctx.subdGroup();
	if (groupname.isstring())
	    return true;

	// If the user didn't specify a subd group on the output driver, use
	// the object settings instead.  If the vm_rendersubd or ri_rendersubd
	// toggles are turned on, we will render the object as subdivision
	// surfaces.
	OP_Network	*obj = sop->getCreator();
	if (!isToggleEnabled(obj, "vm_rendersubd", ctx, false) &&
		!isToggleEnabled(obj, "ri_rendersubd", ctx, false))
	{
	    return false;
	}
	// However, if the user has specified a special group for subd
	// surfaces, we only render primitives in that group as subds, while
	// all others are rendered as polygons.
	if (!obj->evalParameterOrProperty("vm_subdgroup", 0, 
		    ctx.cookTime(), groupname))
	{
	    groupname = "";
	}
	return true;
    }

    static const char *
    homogenizePath(const char *path, UT_WorkBuffer storage, bool &flag)
    {
        const char *pos1 = path;
        const char *pos2;
        bool        slash;

        flag = false;
        storage.clear();

        while (true)
        {
            slash = false;
            while (*pos1 == '/')
            {
                // If flag has been marked true before, it will be true from
                // now on. A single slash will trip slash, then a second
                // will trip flag.
                flag = flag || slash;
                slash = true;

                ++pos1;
            }
            if (*pos1 == 0)
            {
                break;
            }

            pos2 = strchr(pos1, '/');
            if (!pos2)
            {
                storage.append(pos1);
                break;
            }

            storage.append(pos1, pos2 - pos1 + 1);
            pos1 = pos2;
        }

        return storage.buffer();
    }

    // Sort primitives using strcmp semantics.
    //
    // When placing a packed Alembic directly using a path, the first packed
    // Alembic has its transform matrix merged with its parents' transform
    // matrix. This is because in most cases, we only have one shape underneath
    // a transform. By merging the matrices, we improve the speed and
    // archive file size.
    //
    // However, there may be multiple shapes under a single transform. In
    // addition, these shapes may be a mix of packed Alembics and deforming
    // geometry. In this case, we need to apply an inverse transform to the
    // deforming geometry and the parent transforms of additional packed
    // Alembics.
    //
    // Thus, partitions with shorter paths must be processed first so that
    // the parent transform matrices are available to their children for
    // computing the inverse. In addition, partitions with packed Alembics
    // must come before partitions without any, so that the inverse of the
    // first packed Alembics transform is available when we write deforming
    // geometry.
    static int
    comparePrims(const abc_PrimContainer *a, const abc_PrimContainer *b)
    {
        // Partitions with the shorter path come first.
        UT_String       str_a(*(a->myIdentifier));
        UT_String       str_b(*(b->myIdentifier));
        UT_WorkArgs     tokens_a, tokens_b;

        str_a.tokenize(tokens_a, '/');
        str_b.tokenize(tokens_b, '/');

        if (tokens_a.entries() < tokens_b.entries())
        {
            return -1;
        }
        else if (tokens_a.entries() > tokens_b.entries())
        {
            return 1;
        }

        // If same partitions have same path length, then partitions with
        // packed Alembics come first
        if (a->myHasAlembic && !b->myHasAlembic)
        {
            return -1;
        }
        else if (!a->myHasAlembic && b->myHasAlembic)
        {
            return 1;
        }

        // Same path length, both/neither have Alembics, order doesn't matter
        return 0;
    }

    SOP_Node *
    getSop(int id)
    {
	OP_Node	*node = OP_Node::lookupNode(id);
	return UTverify_cast<SOP_Node *>(node);
    }
}

ROP_AbcSOP::ROP_AbcSOP(SOP_Node *node)
    : mySopId(node ? node->getUniqueId() : -1)
    , myElapsedFrames(0)
    , myTimeDependent(false)
{
}

ROP_AbcSOP::~ROP_AbcSOP()
{
    clear();
}

void
ROP_AbcSOP::clear()
{
    for (int i = 0; i < myShapes.entries(); ++i)
    {
	delete myShapes(i);
    }
    myShapes.setCapacity(0);

    for (auto it = myXformMap.begin(); it != myXformMap.end(); ++it)
    {
        delete it->second;
    }
    myXformMap.clear();

    myInverseMap.clear();
    myGeoSet.clear();
    myNameMap.clear();
    myPartitionIndices.clear();
    myPartitionMap.clear();
    myPartitionNames.clear();

    GABC_OGTGeometry::clearIgnoreList();
}

bool
ROP_AbcSOP::start(const OObject &parent,
	GABC_OError &err, const ROP_AbcContext &ctx, UT_BoundingBox &box)
{
    const GU_Detail	           *gdp;
    GU_DetailHandle	            gdh;
    PrimitiveList	            prims;
    ROP_AbcGTCompoundShape	   *shape;
    SOP_Node                       *sop = getSop(mySopId);
    UT_Set<std::string>             uniquenames;
    std::string		            name = getName();

    if (!sop)
    {
        clear();
        return err.error("Unable to find SOP: %d", mySopId);
    }

    gdh = sop->getCookedGeoHandle(ctx.cookContext());
    gdp = GU_DetailHandleAutoReadLock(gdh).getGdp();

    if (!gdp)
    {
        clear();
        UT_WorkBuffer	path;
        sop->getFullPath(path);
        return err.error("Error saving first frame: %s", path.buffer());
    }

    myParent = parent;
    myTimeDependent = sop->isTimeDependent(ctx.cookContext());

    if (ctx.fullBounds())
    {
        gdp->computeQuickBounds(myBox);
        box = myBox;
    }
    if (ctx.buildFromPath())
    {
        GABC_OGTGeometry::skipAttribute(ctx.pathAttribute());
    }

    myPartitionIndices.append(GA_OffsetList());
    myPartitionNames.push_back(name);
    partitionGeometry(prims,
            sop,
            *gdp,
            ctx,
            err);
    if (ctx.buildFromPath())
    {
        prims.sort(comparePrims);
    }

    for (int i = 0; i < prims.entries(); ++i)
    {
        // Create new compound shapes
        shape = new ROP_AbcGTCompoundShape(*(prims(i).myIdentifier),
                &myInverseMap,
                &myGeoSet,
                &myXformMap,
                prims(i).myHasPartition,
                prims(i).mySubdMode,
                prims(i).myShowPts);

        if (!shape->first(prims(i).myPrim, myParent, err, ctx, false))
        {
            clear();
            UT_WorkBuffer   path;
            sop->getFullPath(path);
            return err.error("Error saving first frame: %s", path.buffer());
        }

        myShapes.append(shape);

        // Map partition names to specific compound shapes
        if (ctx.buildFromPath())
        {
            myNameMap.insert(NameMapInsert(*(prims(i).myIdentifier), i));
        }
    }

    ++myElapsedFrames;

    // Update any OXform objects that were created and set for this
    // frame but not written out.
    if (ctx.buildFromPath())
    {
        for (auto it = myXformMap.begin(); it != myXformMap.end(); ++it)
        {
            GABC_OXformSchema  &schema = it->second->getSchema();

            if (schema.getNumSamples() < myElapsedFrames)
            {
                schema.finalize();
            }
        }
        myInverseMap.clear();
    }

    return true;
}

bool
ROP_AbcSOP::update(GABC_OError &err,
	const ROP_AbcContext &ctx, UT_BoundingBox &box)
{
    const GU_Detail	           *gdp;
    GU_DetailHandle	            gdh;
    NameMap::iterator               it;
    PrimitiveList	            prims;
    ROP_AbcGTCompoundShape	   *shape;
    SOP_Node                       *sop = getSop(mySopId);
    std::string		            name = getName();

    if (!sop)
    {
        clear();
        return err.error("Unable to find SOP: %d", mySopId);
    }

    gdh = sop->getCookedGeoHandle(ctx.cookContext());
    gdp = GU_DetailHandleAutoReadLock(gdh).getGdp();

    if (!gdp)
    {
        clear();
        UT_WorkBuffer	path;
        sop->getFullPath(path);
        return err.error("Error saving first frame: %s", path.buffer());
    }

    myTimeDependent = sop->isTimeDependent(ctx.cookContext());

    if (ctx.fullBounds())
    {
	gdp->computeQuickBounds(myBox);
	box = myBox;
    }

    partitionGeometry(prims,
            sop,
            *gdp,
            ctx,
            err);
    if (ctx.buildFromPath())
    {
        prims.sort(comparePrims);
    }

    for (int i = 0; i < prims.entries(); ++i)
    {
        // Use myNameMap if we're partitioning the data.
        if (!myNameMap.empty())
        {
            it = myNameMap.find(*(prims(i).myIdentifier));

            // Create a new compound shape if one does not exist
            // for the current partition.
            if (it == myNameMap.end())
            {
                shape = new ROP_AbcGTCompoundShape(*(prims(i).myIdentifier),
                        &myInverseMap,
                        &myGeoSet,
                        &myXformMap,
                        prims(i).myHasPartition,
                        prims(i).mySubdMode,
                        prims(i).myShowPts);

                // Write out the first frame with hidden visibility
                if (!shape->first(prims(i).myPrim,
                        myParent,
                        err,
                        ctx,
                        false,
                        Alembic::AbcGeom::kVisibilityHidden))
                {
                    clear();
                    UT_WorkBuffer   path;
                    sop->getFullPath(path);
                    return err.error("Error saving next frame: %s", path.buffer());
                }
                // Copy the data up to the current frame, still hidden
                shape->updateFromPrevious(err,
                        Alembic::AbcGeom::kVisibilityHidden,
                        myElapsedFrames - 1);
                // Copy the data for the current frame, this time visible
                shape->updateFromPrevious(err,
                        Alembic::AbcGeom::kVisibilityDeferred);

                // Add the partition to the list and the map
                myShapes.append(shape);
                myNameMap.insert(NameMapInsert(*(prims(i).myIdentifier),
                        (myShapes.entries() - 1)));
            }
            // Otherwise, just update the existing shape
            else
            {
                if (!myShapes(it->second)->update(prims(i).myPrim, err, ctx))
                {
                    clear();
                    UT_WorkBuffer   path;
                    sop->getFullPath(path);
                    return err.error("Error saving next frame: %s", path.buffer());
                }
            }
        }
        // If we're not using partitions, just update the existing shapes
        // in the same order they were written in the first frame.
        else
        {
            // The number of existing shapes should match the number of existing
            // primitives always
            UT_ASSERT(myShapes.entries() == prims.entries());

            for (int i = 0; i < prims.entries(); ++i)
            {
                if (!myShapes(i)->update(prims(i).myPrim, err, ctx))
                {
                    clear();
                    UT_WorkBuffer   path;
                    sop->getFullPath(path);
                    return err.error("Error saving next frame: %s", path.buffer());
                }
            }
        }
    }

    // Update all hidden shapes
    for (int i = 0; i < myShapes.entries(); ++i)
    {
        if (myShapes(i)->getElapsedFrames() == myElapsedFrames)
        {
            myShapes(i)->updateFromPrevious(err);
        }
    }

    ++myElapsedFrames;

    // Update any OXform objects that were created and set for this
    // frame but not written out.
    if (ctx.buildFromPath())
    {
        for (auto it = myXformMap.begin(); it != myXformMap.end(); ++it)
        {
            GABC_OXformSchema  &schema = it->second->getSchema();

            if (schema.getNumSamples() < myElapsedFrames)
            {
                schema.finalize();
            }
        }
        myInverseMap.clear();
    }

    return true;
}

bool
ROP_AbcSOP::selfTimeDependent() const
{
    return myTimeDependent;
}

bool
ROP_AbcSOP::getLastBounds(UT_BoundingBox &box) const
{
    box = myBox;
    return true;
}

void
ROP_AbcSOP::partitionGeometryRange(PrimitiveList &primitives,
        const GU_Detail &gdp,
        const GA_Range &range,
        const ROP_AbcContext &ctx,
        GABC_OError &err,
        bool force_subd_mode,
        bool show_pts)
{
    GA_ROHandleS            str;
    GA_StringIndexType      idx;
    UT_WorkBuffer           namebuf;
    int                     pos;
    const char             *aname;
    const char             *strval;
    bool                    from_path = ctx.buildFromPath();
    bool                    flag = false;

    aname = from_path ? ctx.pathAttribute() : ctx.partitionAttribute();

    str = GA_ROHandleS(gdp.findStringTuple(GA_ATTRIB_PRIMITIVE, aname));
    if (!str.isValid() || !str.getAttribute()->getAIFSharedStringTuple())
    {
        buildGeometry(primitives,
                gdp,
                range,
                getName(),
                false,
                false,
                force_subd_mode,
                show_pts);
        return;
    }

    for (GA_Iterator it(range); !it.atEnd(); ++it)
    {
        idx = str.getIndex(*it);
        if (idx < 0)
        {
            myPartitionIndices(0).append(*it);
        }
        // Originally mapped string index to PrimitiveList, but the string
        // table is not constant. Thus, need to map processed strings to
        // PrimitiveList.
        else
        {
            // Read and process the path string.
            strval = str.get(*it);
            strval = from_path
                    ? homogenizePath(strval, namebuf, flag)
                    : ctx.partitionModeValue(strval, namebuf);

            // Report warnings if the path string was invalid or odd
            // (multiple consecutive '/'s)
            if (*strval == 0)
            {
                err.warning("Invalid %s attribute value for primitive "
                        "%" SYS_PRId64 " was ignored.",
                        aname,
                        ((int64)(*it) - 1));

                myPartitionIndices(0).append(*it);
                continue;
            }
            else if (from_path && flag)
            {
                err.warning("%s attribute value for primitive %" SYS_PRId64
                        " has odd value. Value interpreted as %s.",
                        aname,
                        ((int64)(*it) - 1),
                        strval);
            }

            PartitionMap::iterator  iter2 = myPartitionMap.find(strval);

            // If we've seen this string before, fetch the position of the
            // corresponding list of primitives.
            if (iter2 != myPartitionMap.end())
            {
                pos = iter2->second;
            }
            // Otherwise: create a new list of primitives, record its
            //            index, and store the partition identifier
            else
            {
                pos = myPartitionIndices.entries();
                myPartitionIndices.append(GA_OffsetList());
                myPartitionNames.push_back(strval);

                myPartitionMap.insert(PartitionMapInsert(strval, pos));
            }

            myPartitionIndices(pos).append(*it);
        }
    }

    // Group the primitives for each partition into a GT_Primitive
    for (exint i = 0; i < myPartitionIndices.entries(); ++i)
    {
        if (myPartitionIndices(i).entries())
        {
            GA_Range    range(gdp.getPrimitiveMap(), myPartitionIndices(i));

            buildGeometry(primitives,
                    gdp,
                    range,
                    myPartitionNames[i],
                    (i != 0),
                    from_path,
                    force_subd_mode,
                    show_pts);

            myPartitionIndices(i).clear();
        }
    }
}

void
ROP_AbcSOP::partitionGeometry(PrimitiveList &primitives,
        const SOP_Node *sop,
        const GU_Detail &gdp,
        const ROP_AbcContext &ctx,
        GABC_OError &err)
{
    UT_String	subdgroupname;

    if (objectSubd(sop, ctx, subdgroupname))
    {
        if (subdgroupname.isstring())
        {
            // If there's a group name, only the primitives in the group
            // should be rendered as subd surfaces.
            const GA_PrimitiveGroup	*subdgroup
                    = gdp.findPrimitiveGroup(subdgroupname);
            if (subdgroup)
            {
                // Build subdivision groups first
                partitionGeometryRange(primitives,
                        gdp,
                        GA_Range(*subdgroup),
                        ctx,
                        err,
                        true,
                        false);
                // Now, build the polygons
                partitionGeometryRange(primitives,
                        gdp,
                        GA_Range(*subdgroup, true),
                        ctx,
                        err,
                        false,
                        true);
            }
            else
            {
                // If there was no group, then there are no subd surfaces
                partitionGeometryRange(primitives,
                        gdp,
                        gdp.getPrimitiveRange(),
                        ctx,
                        err,
                        false,
                        true);
            }
        }
        else
        {
            // All polygons should be rendered as subd primitives
            partitionGeometryRange(primitives,
                    gdp,
                    gdp.getPrimitiveRange(),
                    ctx,
                    err,
                    true,
                    true);
        }
    }
    else
    {
        // No subdivision primitives
        partitionGeometryRange(primitives,
                gdp,
                gdp.getPrimitiveRange(),
                ctx,
                err,
                false,
                true);
    }
}
